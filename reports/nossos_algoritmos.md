# 6. Algoritmos e Estrat√©gias implementadas

A primeira e segunda fase planeadas na primeira parte do trabalho serviram de base para desenvolver a fase que realmente consideramos crucial, a fase III, na qual j√° se tem em conta as v√°rias condicionantes do problema, entre as quais as dist√¢ncias dos estafetas aos restaurantes dos pedidos, as capacidades m√°ximas de transporte, os meios de transporte utilizados e a disponibilidade dos estafetas.
Como tal, todos estes fatores que foram ignorados numa fase inicial do desenvolvimento do trabalho, na qual s√≥ se pretendia abordar o problema na sua ess√™ncia, s√£o, na aplica√ß√£o final, trabalhados tanto para o caso de um estafeta como para o caso em que existem v√°rios.

Para melhor analisar a implementa√ß√£o, optamos, ent√£o, por descrever sucintamente as estrat√©gias adotadas para cada caso de utiliza√ß√£o, acompanhadas de pseudo-c√≥digo.

## 6.1. Um ou v√°rios pedidos por ordem temporal

Para o caso em que √© feito um pedido ou v√°rios, cada um de um √∫nico restaurante, e existem m√∫ltiplos estafetas para o realizar, seguimos a estrat√©gia descrita na fase III para a escolha do estafeta.

A implementa√ß√£o deste caso tem como base a fun√ß√£o: 
`vector<SingleTask*> distributeRequests(Graph<Coordinates> & graph, Graph<Coordinates> & reducedGraph, min_priority_queue & requests, vector<Employee*> & employees)` - definida em `SingleTask.cpp`; que devolve um conjunto de tarefas, consistindo uma tarefa na atribui√ß√£o de um pedido a um estafeta.

Come√ßa-se por verificar que tipos de meio de transporte podem ser utilizados para completar cada pedido, tendo em conta que s√£o utilizados grafos diferentes para representar os caminhos transit√°veis a p√©/bicicleta e aqueles que podem ser percorridos de carro/motociclo. Para isso, s√£o atualizadas as vari√°veis `deliverableByCar` e `deliverableByFoot` do pedido, consoante exista ou n√£o um caminho entre o v√©rtice do restaurante e a morada de entrega no grafo correpondente a cada meio de transporte. Utiliza-se a fun√ß√£o `setRequestsDeliverability(const Graph<Coordinates> & graph, const Graph<Coordinates> & reducedGraph, min_priority_queue & requests)` para realizar esta verifica√ß√£o.

Seguidamente, realizando os pedidos por ordem temporal, para a escolha de um estafeta para cada pedido, come√ßa-se por definir as dist√¢ncias dos estafetas ao restaurante, armazenadas na matriz de dist√¢ncias calculada previamente com o algoritmo de Floyd Warshall - `setDistancesToCheckpoint(Graph<Coordinates> & graph, Graph<Coordinates> & reducedGraph, vector<Employee*> & employees, Request & request)`. A√≠, verifica-se tamb√©m se existe um caminho entre estes dois pontos no grafo de cada meio de transporte e imp√µe-se uma dist√¢ncia limite para a realiza√ß√£o de pedidos de bicicleta ou a p√©, evitando trajetos excessivamente longos para estafetas que utilizem este meio de transporte. 

O passo seguinte, √© excluir todos os estafetas que n√£o t√™m possibilidade de entregar o pedido, n√£o s√≥ devido aos fatores anteriores mas tamb√©m por n√£o terem capacidade para o transportar ou por n√£o estarem dispon√≠veis - `getEligibleEmployees(vector<Employee*> & employees, const Request & request)`.

Finalmente, de todos os estafetas dispon√≠veis, a escolha passa pela conjuga√ß√£o de tr√™s fatores: dist√¢ncia mais curta at√© ao restaurante, carga e velocidade m√©dia do meio de transporte, dando prioridade √† dist√¢ncia, com um peso de 50% na decis√£o. Para isso utiliza-se o operador menor da classe `Employee` para escolher o estafeta a realizar o pedido.

```cpp
bool Employee::operator<(const Employee &rhs) const {
    return dist*0.5 + maxCargo*0.3 + avgVelocity * 0.2 < rhs.getDist()*0.5 + rhs.getMaxCargo()* 0.3 + rhs.getAvgVelocity() * 0.2 ;
}
```

Definido um estafeta para um dado pedido, este √© marcado como indispon√≠vel, sendo necess√°rio distribuir os restantes pedidos pelos estafetas dispon√≠veis. 
Como existem pedidos que s√≥ podem ser realizados por alguns estafetas espec√≠ficos, devido √† sua carga ou fraca acessibilidade dos seus v√©rtices, alguns pedidos n√£o ser√£o atribu√≠dos √† primeira tentativa, utilizando-se uma fila de prioridade auxiliar `pendingRequests` para os guardar.

Assim que uma ronda de distribui√ß√£o de pedidos termina, isto √©, assim que todos os estafetas tenham um pedido atribu√≠do, volta-se a disponibilizar todos os estafetas para a distribui√ß√£o dos restantes pedidos e constr√≥i-se o caminho mais curto para cada estafeta realizar o pedido que lhe foi atribu√≠do - `setFloydWarshallPath(Graph<Coordinates> & graph)` - em `SingleTask.cpp`; obtendo o caminho mais curto entre a posi√ß√£o do estafeta e o restaurante e entre o restaurante e a morada de entrega.

Assim que n√£o existirem mais pedidos para distribuir, havendo a possibilidade de existirem pedidos que nenhum estafeta tenha condi√ß√µes para realizar - por os seus v√©rtices serem inacess√≠veis ou por nenhum estafeta ter capacidade para o transportar; s√£o devolvidas todas as tarefas que fazem corresponder cada pedido com o estafeta que ficou respons√°vel por ele.

```cpp
distributeRequests(Graph G1, Graph G2, PriorityQueue<Request> R, vector<Employee> E){
    vector<SingleTask> task; // Para devolver a distribui√ß√£o dos pedidos pelos estafetas
    vector<SingleTask> roundTasks; // A cada ronda de distribui√ß√£o guarda as tarefas

    PriorityQueue<Request> pendingRequests ü†Ñ ‚àÖ // Para guardar pedidos pendentes
    R ‚Üê setRequestsDeliverability(G1,G2,R) // Para definir se um pedido pode ou n√£o ser entregue por cada meio de transporte

    while R != ‚àÖ :
        Request request ‚Üê R.top() // Entregar um pedido de cada vez
        R.pop();

        setDistancesToCheckpoint(G1, G2, E, request);
        eligibleEmployees ‚Üê getEligibleEmployees(E, request);

        if E == ‚àÖ :
            pendingRequests.push(request); // Nenhum estafeta elig√≠vel no momento
        else :
            sort(E); // de acordo com o operador <
            ready(E[0]) ‚Üê false; // Ocupar o estafeta com o pedido
            SingleTask task(E[0], request); // Definir tarefa que associa o estafeta ao pedido

        if Q == ‚àÖ :
            /*...*/ // Aqui verifica-se se um pedido n√£o pode ser entregue a nenhum estafeta. Detalhes podem ser consultados no c√≥digo fonte.

            for each task ‚àà roundTasks :
                if VehicleType(task) == CAR || VehicleType(task) == MOTORCYCLE :
                    task.setFloydWarshallPath(G1);
                if VehicleType(task) == BIKE || VehicleType(task) == FOOT :
                    task.setFloydWarshallPath(G2); // Constru√ß√£o do caminho do estafeta 

            tasks.insert(roundTasks);
            roundTasks.clear(); 
    return tasks;
}
```


## 6.2. Pedido de m√∫ltiplos restaurantes

Um outro caso de utiliza√ß√£o consiste na atribui√ß√£o de um pedido que inclui refei√ß√µes de mais do que um restaurante, cuja implementa√ß√£o se centra essencialmente na fun√ß√£o `SingleTask * multipleRestaurantsRequest(Graph<Coordinates> & graph, Graph<Coordinates> & reducedGraph, vector<Employee*> & employees, Request & request)` - definida em `SingleTask.cpp`.
Para isso, determinam-se, mais uma vez, quais os estafeta elig√≠veis para realizar o pedido. Neste caso, no entanto, s√≥ podemos descartar, numa fase inicial, aqueles estafetas que n√£o possuam capacidade para transportar a carga do pedido. 
Seguidamente, determina-se para cada estafeta o caminho a seguir para recolher o pedido dos restaurantes, escolhendo sempre o restaurante mais perto  - `int getNearestRestaurant(Graph<Coordinates> & graph, const Coordinates & origin, vector<Coordinates> & restaurants)`; (consultando a matriz de dist√¢ncias pr√© calculada com o algoritmo de Floyd Warshall). Mant√©m-se sempre guardada a melhor dist√¢ncia, o estafeta ao qual essa dist√¢ncia corresponde e a ordem de visita dos restaurantes, tendo sempre em aten√ß√£o que pode n√£o existir caminho poss√≠vel, no caso de alguns meios de transporte (dependendo do grafo de entrada). No fim, √© escolhido o estafeta ao qual corresponde a melhor dist√¢ncia.

Mais uma vez, para definir o caminho completo a percorrer pelo estafeta, utiliza-se a fun√ß√£o `setFloydWarshallPath(Graph<Coordinates> & graph)` - em `SingleTask.cpp`; que calcula o caminho mais curto entre restaurantes consecutivos cuja ordem de visita j√° fora determinada no algoritmo descrito.

```cpp
multipleRestaurantsRequest(Graph G1, Graph G2, vector<Employee> E, Request request){
    vector<Coordinates> restaurants; // Restaurantes por ordem de visita
    int nearestEmployeePos; // Guardar a cada itera√ß√£o o estafeta ao qual corresponde a melhor dist√¢ncia
    int nearestRestaurantPos; // Guardar para cada estafeta o restaurante mais pr√≥ximo dos que faltam visitar  
    double nearestEmployeeDist ‚Üê INF; // Inicializar a melhor dist√¢ncia com valor elevado

    employees ‚Üê getEligibleEmployeesMultipleRestaurants(E, request);

    for i = 0 to E.size(): // Repetir procedimento para cada estafeta dispon√≠vel
        double totalDist ‚Üê 0;
        Coordinates orig ‚Üê coords(E[i]); // Posi√ß√£o inicial do estafeta
        vector<Coordinates> requestRestaurants ‚Üê checkpoints(request); // Restaurantes por visitar
        vector<Coordinates> restaurantsPath; // Ordem de visita dos restaurantes se o estafeta por escolhido

        for j = 0 to checkpoints(request).size() :
            double dist ‚Üê 0; // Calcular a dist√¢ncia a percorrer pelo estafeta se for escolhido
            if vehicle(E[i]) == CAR ||vehicle(E[i]) == MOTORCYCLE :
                nearestRestaurantPos ‚Üê getNearestRestaurant(G1, orig, requestRestaurants); // Restaurante por visitar mais perto do anterior

                dist ‚Üê G1.getDist(orig, requestRestaurants[nearestRestaurantPos]);
                /*...*/
                if dist == INF : // N√£o foi encontrado caminho para o estafeta realizar o pedido
                    totalDist ‚Üê INF; break;
            
            else if vehicle(E[i]) == BIKE ||vehicle(E[i]) == FOOT :
                /*Procedimento semelhante ao anterior mas para o grafo destes meios de transporte*/

            totalDist ‚Üê totalDist + dist; // Acumular dist√¢ncia
            restaurantsPath.push_back(requestRestaurants[nearestRestaurantPos]); // Guardar restaurantes por ordem de visita
            orig ‚Üê requestRestaurants[nearestRestaurantPos]; // Atualizar posi√ß√£o anterior
            requestRestaurants.erase(requestRestaurants.begin() + nearestRestaurantPos); // Eliminar dos restaurantes por visitar

        // N√£o escolher o estafeta se n√£o foi encontrado caminho ou se, no caso de se deslocar a p√© ou de bicicleta, o caminho ultrapassa 6km 
        if totalDist == INF || (totalDist > 6000 && (vehicle(E[i]) == BIKE || vehicle(E[i]) == FOOT))):
            continue; 

        // Adicionar a dist√¢ncia √† morada de destino
        if vehicle(E[i]) == CAR || vehicle(E[i]) == MOTORCYCLE :
            double dist ‚Üê G.getDist(restaurantsPath[restaurantsPath.size()-1]),deliveryAddr(request));
            /*...*/
            if(dist == INF) break;
            totalDist ‚Üê totalDist + dist;
        
        else if vehicle(E[i]) == BIKE || vehicle(E[i]) == FOOT) :
            double dist ‚Üê G.getDist(restaurantsPath[restaurantsPath.size()-1]),deliveryAddr(request));
            /*...*/
            if(dist == INF || totalDist + dist > 6000) break;
             totalDist ‚Üê totalDist + dist;
        
        // Se a dist√¢ncia for melhor que a do estafeta anterior, guarda-se a dist√¢ncia, o caminho e o estafeta
        if totalDist < nearestEmployeeDist : 
            nearestEmployeePos ‚Üê i;
            nearestEmployeeDist ‚Üê totalDist;
            restaurants ‚Üê restaurantsPath;
    }

    // Se n√£o foi encontrado nenhum estafeta para realizar o pedido retornar tarefa vazia
    if nearestEmployeeDist == INF : return SingleTask(nullptr, request);

    request.setCheckpoints(restaurants); // Guardar os restaurantes por ordem de visita
    SingleTask task ‚Üê SingleTask(E[nearestEmployeePos], request); // Tarefa que associa pedido e estafeta

    if vehicle(task) == CAR || vehicle(task) == MOTORCYCLE:
        task.setFloydWarshallPath(G1); // Constru√ß√£o do caminho do estafeta
    if vehicle(task) == BIKE || vehicle(task) == FOOT :
        task.setFloydWarshallPath(G2);

    return task;
}

```

## 6.3. Um estafeta - entrega de v√°rios pedidos no mesmo deslocamento (variante do TSP)

Outra alternativa que pensamos ser essencial incluir na nossa implementa√ß√£o, tendo em conta a ess√™ncia do problema, foi o caso em que um s√≥ estafeta deve, num s√≥ trajeto, recolher todos os pedidos dos restaurantes e entreg√°-los nas respetivas moradas de entrega, tendo em aten√ß√£o que o restaurante de um pedido deve sempre ser visitado antes da morada de entrega e que podem existir m√∫ltiplos pedidos do mesmo restaurante.

Para isso, na fun√ß√£o `SpecialTask * simultaneousRequests(Graph<Coordinates> & graph, vector<Request> & requests, Employee* employee)` - definida em `SpecialTask.cpp`, utilizam-se dois vetores auxiliares que acabam por funcionar como filas, uma com o restaurante n√£o visitado mais pr√≥ximo da posi√ß√£o atual do estafeta √† cabe√ßa e outra com a morada de entrega n√£o visitada mais pr√≥xima da posi√ß√£o atual do estafeta √† cabe√ßa.
Estas posi√ß√µes mais pr√≥ximas s√£o atualizadas nas fun√ß√µes: `setNearestRestaurant(Graph<Coordinates> & graph, vector<Request>  & requests, Coordinates origin)` e `setNearestDeliveryAddress(Graph<Coordinates> & graph, vector<Request>  & requests, Coordinates origin)`, chamadas a cada itera√ß√£o.

Enquanto existirem restaurantes ou moradas de entrega por visitar, o pr√≥ximo ponto a visitar √© escolhido do seguinte modo:
- Na primeira itera√ß√£o e sempre que n√£o h√° pedidos para entregar √© necess√°rio recolher um pedido de um restaurante;
- Quando a carga m√°xima √© atingida ou j√° foram recolhidos todos os pedidos √© necess√°rio entregar um pedido;
- Se existir capacidade para tal, recolhe-se m√∫ltiplos pedidos de restaurantes dos quais tenha sido feito mais do que um pedido;
- No caso de haver possibilidade de entregar ou recolher um pedido, opta-se por escolher o deslocamento de menor dist√¢ncia;

A ordem de visita dos v√°rios pontos √© guardada num vetor, que mant√©m a associa√ß√£o das coordenadas do ponto com o pedido ao qual este est√° associado, de modo a facilitar c√°lculos posteriores de tempos estimados.

Finalmente, √© definido o caminho completo e tamb√©m os tempos estimados para cada pedido na fun√ß√£o `setFloydWarshallPath(Graph<Coordinates> & graph, const vector<pair<Coordinates,unsigned long>> & checkpoints)` - em `SpecialTask.cpp`; que procede de modo similar √† fun√ß√£o do mesmo nome descrita anteriormente, calculando o caminho mais curto entre cada par de pontos consecutivos do caminho parcial.

```cpp
simultaneousRequests(Graph G, vector<Request> R, Employee employee){
    vector<Coordinates> path; // Caminho parcial - ordem de visita dos restaurantes e moradas de entrega
    Coordinates orig ‚Üê coordinates(employee); // Ponto de origem √© a posi√ß√£o do estafeta
    
    vector<Request> pick ‚Üê R; // Pedidos a recolher do restaurante
    setNearestRestaurant(G, pick, orig); // Obter na frente do vetor o restaurante mais perto da origem
    vector<Request> deliver; // Pedidos a ser entregues na morada respetiva (j√° recolhidos previmente)

    int totalCargo ‚Üê 0;
    while deliver == ‚àÖ || pick == ‚àÖ :
        // O estafeta n√£o tem mais capacidade / N√£o h√° mais pedidos para recolher do restaurante
        if totalCargo == maxCargo(e) || pick == ‚àÖ :
            // Entrega um pedido 
            orig ‚Üê deliveryAddr(deliver.front());
            path.push_back(orig);
            totalCargo ‚Üê totalCargo - cargo(deliver.front());
            deliver.erase(deliver.begin()); // Remover dos pedidos a entregar

        // N√£o h√° mais pedidos para entregar
        else if deliver == ‚àÖ :
            // Recolher pedido(s) do restaurante mais perto da localiza√ß√£o atual
            orig ‚Üê restaurant(pick.front());
            path.push_back(orig);
            totalCargo ‚Üê totalCargo + cargo(pick.front());

            // Verificar se h√° mais pedidos do mesmo restaurante e recolh√™-los se poss√≠vel(verifica carga)
            repeatedRestaurants(pick,deliver,totalCargo,maxCargo(employee));

            // Adicionar aos pedidos a entregar, remover dos pedidos a recolher
            deliver.push_back(pick.front());
            pick.erase(pick.begin());
        
        // Escolhe a op√ß√£o mais pr√≥xima - recolher ou entregar um pedido. Se n√£o tiver capacidade entrega um pedido
        else:
            if(totalCargo + cargo(pick.front()) > maxCargo(employee) ||
                 G.getDist(orig,deliveryAddr(deliver.front())) < G.getDist(orig,restaurant(pick.front()))):
                /* ... Entrega um pedido .... */
            else:
                /* ... Recolhe pedido(s) do restaurante mais perto... */

        setNearestRestaurant(G,pick,orig); // Manter no in√≠cio o pedido por recolher cujo restaurante est√° mais pr√≥ximo da posi√ß√£o atual
        setNearestDeliveryAddress(G,deliver,orig); // Manter na frente o pedido a entregar cuja morada de entrega √© mais pr√≥xima da posi√ß√£o atual

    SpecialTask s(employee,R); // Atribuir uma tarefa ao estafeta que consiste na realiza√ß√£o de v√°rios pedidos num deslocamento
    s.setFloydWarshallPath(G,path); // Indicar ordem de visita dos restaurantes e moradas para construir a rota total do estafeta
    return s;
}

```

## 6.5. Nota geral acerca dos algoritmos implementados

Por fim, √© de salientar a vantagem proporcionada pelo pr√©-processamento com o algoritmo de Floyd Warshall quando utilizados algoritmos como os descritos acima.
Para efeitos de compara√ß√£o, no entanto, podem ser consultados em `simulations.cpp` e em `SingleTask.cpp` os algoritmos que testamos na Fase II e que utilizam o algoritmo de Dijkstra na sua implementa√ß√£o. Tamb√©m a an√°lise das fun√ß√µes `virtual void setFloydWarshallPath(Graph<Coordinates> & graph)` e `void setDijkstraPath(Graph<Coordinates> & graph)` permite facilmente perceber que, ao utilizar o Floyd Warshall, √© evitado o c√°lculo repetitivo das dist√¢ncias e do caminho mais curto para cada novo ponto de origem, uma desvantagem do Dijkstra. 

*Parte da fun√ß√£o utilizada para definir o caminho final de um estafeta, nos algoritmos *1* e *2**

```cpp 
void SingleTask::setFloydWarshallPath(Graph<Coordinates> & graph){
    /*...*/
    // Os 'checkpoints' do pedido est√£o por ordem de visita - definida com um dos algoritmos anteriores
    for(Coordinates checkpoint: request.getCheckpoints()){ // Para cada ponto a visitar 
        tempPath = graph.getfloydWarshallPath(orig, checkpoint); // Obter o caminho mais curto desde o ponto anterior
        totalDistance += graph.getDist(graph.findVertexIdx(orig), graph.findVertexIdx(checkpoint)); // acumular a dist√¢ncia
        /*...*/
        path.insert(path.end(),tempPath.begin()+1, tempPath.end()); // Adicionar o caminho calculado ao caminho constru√≠do at√© ent√£o
        orig = checkpoint; // Definir novo ponto de origem
    }
    /*...*/
}
```